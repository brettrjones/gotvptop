//============================================================================
// Copyright (C) 2014 Brett R. Jones 
// Issued to MIT style license by Brett R. Jones in 2017
//
// You may use, copy, modify, merge, publish, distribute, sub-license, and/or sell this software 
// provided this Copyright is not modified or removed and is included all copies or substantial portions of the Software
//
// This code is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
// bjones.engineer@gmail.com
// http://www.nolimitconnect.com
//============================================================================

#include "IsPortOpenTest.h"

#include <GoTvCore/GoTvP2P/P2PEngine/P2PEngine.h>
#include <GoTvCore/GoTvP2P/NetServices/NetServiceHdr.h>
#include <GoTvCore/GoTvP2P/NetServices/NetServiceUtils.h>
#include <GoTvCore/GoTvP2P/Network/NetworkStateMachine.h>
#include <GoTvCore/GoTvP2P/Network/NetworkMgr.h>

#include <CoreLib/VxParse.h>
#include <NetLib/VxSktUtil.h>
#include <NetLib/VxPeerMgr.h>
#include <NetLib/VxSktConnectSimple.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _MSC_VER
# pragma warning(disable: 4355) //'this' : used in base member initializer list
#endif //_MSC_VER

namespace
{
	//============================================================================
    void * IsPortOpenTestThreadFunc( void * pvContext )
	{
		VxThread * poThread = (VxThread *)pvContext;
		poThread->setIsThreadRunning( true );
		IsPortOpenTest * anchorTest = (IsPortOpenTest *)poThread->getThreadUserParam();
        if( anchorTest && false == poThread->isAborted() )
		{
			anchorTest->doIsPortOpenTest();
		}

		poThread->threadAboutToExit();
        return nullptr;
	}
}

//============================================================================
IsPortOpenTest::IsPortOpenTest( P2PEngine& engine, EngineSettings& engineSettings, NetServicesMgr& netServicesMgr, NetServiceUtils& netServiceUtils )
: m_Engine( engine )
, m_EngineSettings( engineSettings )
, m_NetServicesMgr( netServicesMgr )
, m_NetServiceUtils( netServiceUtils )
, m_PingResponseServer( *this )
, m_Port( 0 )
{
}

//============================================================================
void IsPortOpenTest::isPortOpenShutdown( void )
{
	stopPingResponse();
	m_IsPortOpenThread.abortThreadRun( true );
}

//============================================================================
void IsPortOpenTest::fromGuiRunIsPortOpenTest( uint16_t port )
{
	m_Port = port;
	if( ( false == m_Engine.getPeerMgr().isListening() )
		|| ( m_Port != m_Engine.getPeerMgr().getListenPort() ) )
	{
        m_RunningtListenForPortTest = true;
        stopPingResponse();
        startPingResponse();
        LogModule( eLogIsPortOpenTest, LOG_INFO, "IsPortOpenTest::startPingResponse: port %d thread 0x%x", m_Port, VxGetCurrentThreadId() );
        sendTestLog( "Starting Listen on port %d for connection test\n", m_Port );
    }
    else
    {
        m_RunningtListenForPortTest = false;
        LogModule( eLogIsPortOpenTest, LOG_INFO, "IsPortOpenTest already listening on port %d thread 0x%x", m_Port, VxGetCurrentThreadId() );
        sendTestLog( "Already Listening on port %d for connection test\n", m_Port );
    }

	startIsPortOpenThread();
}

//============================================================================
void IsPortOpenTest::startPingResponse( void )
{
	if( m_PingResponseServer.isListening() )
	{
		m_PingResponseServer.stopListening();
	}

	std::string lclIp = m_Engine.getNetworkStateMachine().getLocalNetworkIp();
	if( lclIp.length() )
	{
		m_PingResponseServer.startListening( m_Port, lclIp.c_str() );
        LogModule( eLogIsPortOpenTest, LOG_INFO, "IsPortOpenTest::startPingResponse: listening ip %s port %d thread 0x%x", lclIp.c_str(), m_Port, VxGetCurrentThreadId() );
	}
	else
	{
		m_PingResponseServer.startListening( m_Port );
        LogModule( eLogIsPortOpenTest, LOG_INFO, "IsPortOpenTest::startPingResponse: listening port %d thread 0x%x", m_Port, VxGetCurrentThreadId() );
	}
}

//============================================================================
void IsPortOpenTest::stopPingResponse( void )
{
    if( m_PingResponseServer.isListening() )
    {
        m_PingResponseServer.stopListening();
    }
}

//============================================================================
void IsPortOpenTest::startIsPortOpenThread( void )
{
	m_IsPortOpenThread.abortThreadRun( true );
	while( m_IsPortOpenThread.isThreadRunning() )
	{
		VxSleep( 200 );
	}

	m_IsPortOpenThread.startThread( (VX_THREAD_FUNCTION_T)IsPortOpenTestThreadFunc, this, "IsPortOpenTestThread" );
}

//============================================================================
void IsPortOpenTest::sendTestStatus( EIsPortOpenStatus eStatus, const char * msg, ... )
{
	char as8Buf[ 1024 ];
	va_list argList;
	va_start( argList, msg );
	vsnprintf( as8Buf, sizeof( as8Buf ), msg, argList );
	as8Buf[sizeof( as8Buf ) - 1] = 0;
	va_end( argList );
	IToGui::getToGui().toGuiIsPortOpenStatus( eStatus, as8Buf );
}

//============================================================================
void IsPortOpenTest::sendTestLog( const char * msg, ... )
{
	char as8Buf[ 1024 ];
	va_list argList;
	va_start( argList, msg );
	vsnprintf( as8Buf, sizeof( as8Buf ), msg, argList );
	as8Buf[sizeof( as8Buf ) - 1] = 0;
	va_end( argList );
	IToGui::getToGui().toGuiIsPortOpenStatus( eIsPortOpenStatusLogMsg, as8Buf );
}

//============================================================================
void IsPortOpenTest::doIsPortOpenTest( void )
{
	std::string connectTestUrl;
    std::string netHostUrl;

	m_EngineSettings.getNetServiceWebsiteUrl( connectTestUrl );
    m_EngineSettings.getNetHostWebsiteUrl( netHostUrl );
    LogModule( eLogIsPortOpenTest, LOG_INFO, "attempting connection test with connect test url %s thread 0x%x", 
               connectTestUrl.c_str(), VxGetCurrentThreadId() );
	if( eIsPortOpenStatusTestComplete != doConnectionTest( connectTestUrl, false ) && (connectTestUrl != netHostUrl) )
	{
        LogModule( eLogIsPortOpenTest, LOG_INFO, "attempting connection test with host %s thread 0x%x", 
                   netHostUrl.c_str(), VxGetCurrentThreadId() );
		if( eIsPortOpenStatusTestComplete != doConnectionTest( netHostUrl, true ) )
		{
            LogModule( eLogIsPortOpenTest, LOG_INFO, "failed connection test with both host %s and connect test %s thread 0x%x", 
                       netHostUrl.c_str(), connectTestUrl.c_str(), VxGetCurrentThreadId() );
		}
	}
}

//============================================================================
const char * IsPortOpenTest::getTestName( bool isHost )
{
	return "IS PORT OPEN TEST: ";
}

//============================================================================
EIsPortOpenStatus IsPortOpenTest::doConnectionTest( std::string& nodeUrl, bool isHost )
{
	sendTestLog(	"Testing Port using %s node %s Connection Test Service for port %d\n", 
					isHost ? "NET HOST" : "CONNECTION TEST", 
					nodeUrl.c_str(), 
					m_Port );

	VxSktConnectSimple netServConn;
	std::string strHost;
	std::string strFile;
	uint16_t u16Port;
	VxTimer testTimer;
	double connectTime = 0;
	double sendTime= 0;
	double reponseTime= 0;

    LogModule( eLogIsPortOpenTest, LOG_INFO, "IsPortOpenTest: sec %3.3f : connecting to %s thread 0x%x", 
               testTimer.elapsedSec(), nodeUrl.c_str(), VxGetCurrentThreadId() );
	if( false == netServConn.connectToWebsite(	nodeUrl.c_str(), 
		strHost, 
		strFile, 
		u16Port, 
		NETSERVICE_CONNECT_TIMEOUT ) )
	{
		sendTestStatus( eIsPortOpenStatusConnectFail, "%s Could not connected to %s..Please check settings thread 0x%x", 
                        getTestName( isHost ), nodeUrl.c_str(), VxGetCurrentThreadId() );
		if( false == isHost )
		{
			return doConnectTestFailed( isHost );
		}

		return eIsPortOpenStatusConnectFail;
	}

	netServConn.dumpConnectionInfo();
	std::string strNetActionUrl;
	m_NetServiceUtils.buildIsMyPortOpenUrl( &netServConn, strNetActionUrl, m_Port );
    LogModule( eLogIsPortOpenTest, LOG_INFO, "IsPortOpenTest: action url %s thread 0x%x", strNetActionUrl.c_str(), VxGetCurrentThreadId() );
	connectTime = testTimer.elapsedSec();
    LogModule( eLogIsPortOpenTest, LOG_INFO, "IsPortOpenTest: sec %3.3f : sending %d action data thread 0x%x", 
               connectTime, (int)strNetActionUrl.length(), VxGetCurrentThreadId() );

	RCODE rc = netServConn.sendData( strNetActionUrl.c_str(), (int)strNetActionUrl.length() );
	if( rc )
	{
        LogModule( eLogIsPortOpenTest, LOG_ERROR, "NetActionIsMyPortOpen::doAction: sendData error %d thread 0x%x", rc, VxGetCurrentThreadId() );
		sendTestStatus( eIsPortOpenStatusConnectionDropped,
			"%s Connected to %s but dropped connection (wrong network key ?) %s thread 0x%x", getTestName( isHost ), nodeUrl.c_str(), m_Engine.getNetworkMgr().getNetworkKey(), VxGetCurrentThreadId() );
		return doConnectTestFailed( isHost );
	}

	sendTime = testTimer.elapsedSec();
	LogMsg( LOG_INFO, "IsPortOpenTest: sec %3.3f : waiting for is port open response thread 0x%x", sendTime, VxGetCurrentThreadId() );
	char rxBuf[ 513 ];
    rxBuf[ 0 ] = 0;
	NetServiceHdr netServiceHdr;
	if( false == m_NetServiceUtils.rxNetServiceCmd( &netServConn, 
													rxBuf, 
													sizeof( rxBuf ) - 1, 
													netServiceHdr, 
													IS_PORT_OPEN_RX_HDR_TIMEOUT, 
													IS_PORT_OPEN_RX_DATA_TIMEOUT ) )
	{
		sendTestStatus( eIsPortOpenStatusConnectionDropped,
			"%s Connected to %s but failed to respond (wrong network key ?) thread 0x%x", getTestName( isHost ), nodeUrl.c_str(), VxGetCurrentThreadId() );
		return doConnectTestFailed( isHost );
	}

    rxBuf[ sizeof( rxBuf ) - 1 ] = 0;
	std::string content = rxBuf;
	reponseTime = testTimer.elapsedSec();
    LogModule( eLogIsPortOpenTest, LOG_INFO, "IsPortOpenTest: response len %d total time %3.3fsec connect %3.3fsec send %3.3fsec response %3.3f sec thread 0x%x",
		content.length(),
		reponseTime, connectTime, sendTime - connectTime, reponseTime - sendTime, VxGetCurrentThreadId() );
	if( 0 == content.length() )
	{
        LogModule( eLogIsPortOpenTest, LOG_ERROR, "NetActionIsMyPortOpen::doAction: no content in response thread 0x%x" );
		sendTestStatus( eIsPortOpenStatusInvalidResponse, "%s invalid response content %s\n", getTestName( isHost ), content.c_str(), VxGetCurrentThreadId() );
		return doConnectTestFailed( isHost );
	}

	const char * contentBuf = content.c_str();
	if( '/' != contentBuf[content.length() -1] )
	{
        LogModule( eLogIsPortOpenTest, LOG_ERROR, "NetActionIsMyPortOpen::doAction: no trailing / in content thread 0x%x", VxGetCurrentThreadId() );
		sendTestStatus( eIsPortOpenStatusInvalidResponse, "%s invalid response content %s\n", getTestName( isHost ), content.c_str() );
		return doConnectTestFailed( isHost );
	}

	((char *)contentBuf)[content.length() -1] = 0;

	std::vector<std::string> contentParts;
	StdStringSplit( content, '-', contentParts );
	if( 2 != contentParts.size() )
	{
		LogMsg( LOG_ERROR, "NetActionIsMyPortOpen::doAction: not enough parts to content thread 0x%x", VxGetCurrentThreadId() );
		sendTestStatus( eIsPortOpenStatusInvalidResponse, "%s invalid response content %s\n", getTestName( isHost ), content.c_str() );
		return doConnectTestFailed( isHost );
	}

	std::string retMyExternalIp = contentParts[1];
	std::string strPayload = contentParts[0];
	int iIsOpen = atoi( contentParts[0].c_str() );
    m_Engine.getNetStatusAccum().setIpAddress( retMyExternalIp );

    LogModule( eLogIsPortOpenTest, LOG_VERBOSE, "NetActionIsMyPortOpen::doAction: direct connect %s my ip %s result %d thread 0x%x", strPayload.c_str(), retMyExternalIp.c_str(), iIsOpen, VxGetCurrentThreadId() );
	if( iIsOpen )
	{
		sendTestStatus( eIsPortOpenStatusOpen, "my ip %s port %d is open\n", retMyExternalIp.c_str(), m_Port );
	}
	else
	{
		sendTestStatus( eIsPortOpenStatusClosed, "my ip %s port %d is NOT open (Relay will be required)\n", retMyExternalIp.c_str(), m_Port );
		if( m_Engine.getNetworkStateMachine().getLocalNetworkIp().length()
			&& m_Engine.getNetworkStateMachine().isCellularNetwork() )
		{
			sendTestLog( "NOTE: Most cell phone providers block all ports and you appear to be on a cellular data network\n");
		}
	}

	sendTestLog( "Elapsed Seconds Connect %3.3fsec Send %3.3fsec Respond %3.3f sec", connectTime, sendTime - connectTime, reponseTime - sendTime );
	return doConnectTestSuccess( isHost );
}

//============================================================================
EIsPortOpenStatus IsPortOpenTest::doConnectTestFailed( bool isHost )
{
	sendTestStatus( eIsPortOpenStatusTestComplete,
		"\n" );
	doTestShutdown();
	return eIsPortOpenStatusTestComplete;
}

//============================================================================
EIsPortOpenStatus IsPortOpenTest::doConnectTestSuccess( bool isHost )
{
	sendTestStatus( eIsPortOpenStatusTestComplete,
		"\n" );
	doTestShutdown();
	return eIsPortOpenStatusTestComplete;
}

//============================================================================
void IsPortOpenTest::doTestShutdown( void )
{
    if( m_RunningtListenForPortTest )
    {
        m_PingResponseServer.stopListening();
        m_RunningtListenForPortTest = false;
    }
}

//============================================================================
void IsPortOpenTest::handleTcpData( VxSktBase * sktBase )
{
    LogModule( eLogIsPortOpenTest, LOG_VERBOSE, "IsPortOpenTest::handleTcpData thread 0x%x" );
	if( false == m_NetServiceUtils.verifyAllDataArrivedOfNetServiceUrl( sktBase ) )
	{
        LogModule( eLogIsPortOpenTest, LOG_VERBOSE, "IsPortOpenTest::handleTcpData not all data arrived thread 0x%x", VxGetCurrentThreadId() );
        return;
	}

	NetServiceHdr netServiceHdr;
	EPluginType pluginType = m_NetServiceUtils.parseHttpNetServiceUrl( sktBase, netServiceHdr );
	if( ( ePluginTypeNetServices == pluginType )
		&& ( eNetCmdPing == netServiceHdr.m_NetCmdType ) )
	{
        LogModule( eLogIsPortOpenTest, LOG_VERBOSE, "IsPortOpenTest::handleTcpData got pinged thread 0x%x", VxGetCurrentThreadId() );
		sendTestLog( "got pinged\n");
		std::string content;
		StdStringFormat( content, "PONG-%s", sktBase->getRemoteIp() );
		m_NetServiceUtils.buildAndSendCmd( sktBase, eNetCmdPong, content );
	}
	else
	{
        LogModule( eLogIsPortOpenTest, LOG_VERBOSE, "IsPortOpenTest::handleTcpData got unknown data from ip %s thread 0x%x", sktBase->getRemoteIp(), VxGetCurrentThreadId() );
		sendTestLog( "got unknown data from ip %s\n", sktBase->getRemoteIp() );
	}
}


